/*
 * Copyright (C) 2018 Rafael S. Müller <rafael.mueller1@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package textcrypto.Logic;

import java.io.ByteArrayOutputStream;
import java.io.IOException;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;

import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * This class encrypts and decrypts byte arrays by using a password. AES is used
 * as decrypting algorithm. The mode of operation is set to Cipher Block
 * Chaining (CBC) with a initialization vector (iv). The key is generated by
 * using the provided password and a salt (pseudo random hash). The iv and the
 * salt are composed with the cipher text.
 *
 * source: http://stackoverflow.com/questions/992019/java-256-bit-aes-password-based-encryption
 *
 * @author Rafael S. Müller <rafael.mueller1@gmail.com>
 */
public class Crypto {

    private final static int SALT_LENG = 20;
    private final static int IV_LENG = 16; // always 16 bytes (==128 bits)

    private final static int KEY_SIZE = 256; // either 128 or 192 or 256
    private final static int ITERATION = 65536;

    /**
     * Encrypts a byte array by using the provided password.
     *
     * @param plainText byte array which should be encrypted
     * @param password byte array which contains the password
     * @return encrypted byte array.
     * @throws java.security.InvalidKeyException
     * @throws java.security.NoSuchAlgorithmException
     */
    public static byte[] encrypt(byte[] plainText, char[] password) throws InvalidKeyException, NoSuchAlgorithmException {
        try {
            byte[] salt = createRandByte(SALT_LENG);
            byte[] iv = createRandByte(IV_LENG);
            // creates the secret key by using the password and the salt.
            SecretKey secret = createKey(password, salt);

            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            IvParameterSpec ivSpec = new IvParameterSpec(iv);
            cipher.init(Cipher.ENCRYPT_MODE, secret, ivSpec);

            ByteArrayOutputStream cipherText = new ByteArrayOutputStream();

            // composes encrypted byte array which the salt and the iv.
            cipherText.write(salt);
            cipherText.write(iv);
            cipherText.write(cipher.doFinal(plainText));

            return cipherText.toByteArray();
        } catch (InvalidAlgorithmParameterException ex) {
            throw new InvalidKeyException("InvalidAlgorithmParameterException",
                                          ex);
        } catch (InvalidKeyException ex) {
            throw new InvalidKeyException("InvalidKeyException: " + ex.
                    getMessage() + ". Max key size:" + Cipher.
                            getMaxAllowedKeyLength("AES"), ex);
        } catch (NoSuchAlgorithmException ex) {
            throw new InvalidKeyException("NoSuchAlgorithmException", ex);
        } catch (BadPaddingException ex) {
            throw new InvalidKeyException("BadPaddingException", ex);
        } catch (IllegalBlockSizeException ex) {
            throw new InvalidKeyException("IllegalBlockSizeException", ex);
        } catch (NoSuchPaddingException ex) {
            throw new InvalidKeyException("NoSuchPaddingException", ex);
        } catch (IOException ex) {
            throw new InvalidKeyException("IOException", ex);
        } catch (InvalidKeySpecException ex) {
            throw new InvalidKeyException("Encryption failed.", ex);
        }
    }

    public static byte[] decrypt(byte[] chipherText, char[] password) throws InvalidKeyException {
        int leng = SALT_LENG + IV_LENG;
        // separate the salt and the iv from the actual chipherText.
        byte[] salt = Arrays.copyOfRange(chipherText, 0, SALT_LENG);
        byte[] iv = Arrays.copyOfRange(chipherText, SALT_LENG, leng);
        chipherText = Arrays.copyOfRange(chipherText, leng, chipherText.length);

        try {
            SecretKey secret = createKey(password, salt);

            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            IvParameterSpec ivSpec = new IvParameterSpec(iv);
            cipher.init(Cipher.DECRYPT_MODE, secret, ivSpec);

            return cipher.doFinal(chipherText);
        } catch (InvalidAlgorithmParameterException | InvalidKeyException | NoSuchAlgorithmException | BadPaddingException | IllegalBlockSizeException | NoSuchPaddingException | InvalidKeySpecException ex) {
            throw new InvalidKeyException(
                    "Decryption failed. Double check password", ex);
        }
    }

    /**
     * This method creates a key from a password and a salt. The salt is used to
     * generate a more secure key from the password.
     *
     * @param password
     * @param salt
     * @return a key which is used the encrypt data.
     */
    private static SecretKey createKey(char[] password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance(
                    "PBKDF2WithHmacSHA256");
            KeySpec keySpec = new PBEKeySpec(password, salt, ITERATION, KEY_SIZE);
            SecretKey temp = factory.generateSecret(keySpec);
            return new SecretKeySpec(temp.getEncoded(), "AES");
        } catch (NoSuchAlgorithmException ex) {
            throw new NoSuchAlgorithmException(
                    "SecretKeyFactors could not find algorithm", ex);
        } catch (InvalidKeySpecException ex) {
            throw new InvalidKeySpecException(
                    "Could not generate secretKey from KeySpec", ex);
        }
    }

    /**
     * This method creates a pseudo random byte array with the indicated length.
     *
     * @param length the length of the pseudo random byte array.
     * @return a pseudo random byte array with the indicated length.
     */
    private static byte[] createRandByte(int length) throws NoSuchAlgorithmException {
        try {
            byte[] randomByte = new byte[length];
            SecureRandom generator = SecureRandom.getInstance("SHA1PRNG");
            generator.nextBytes(randomByte);
            return randomByte;
        } catch (NoSuchAlgorithmException ex) {
            throw new NoSuchAlgorithmException(
                    "SecureRandom could not find algorithm", ex);
        }
    }
}
